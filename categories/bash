###
How would you `echo` all numbers from 1 until 100 using brace expansion?
===
    echo {1..100}

###
How would you `echo` all *odd* numbers from 1 until 100 using brace expansion?
===
    echo {1..100..2}

###
You have `file037` to `file230` in the current dir. How do you delete them using
only the `rm` command (considering there are other, unknown, files in the dir)?
===
    rm file{037..230}

###
Can you escape `'` (single quote) within a single quoted string? If so, how?
===
No. Everything inside `'` is taken literally until another `'`.

###
How can you `echo` a tab character without using the `-e` option?
===
    echo $'\t'

###
What is the difference between `{ cmd1; cmd2; }` and `(cmd1; cmd2)`?
===
The commands are execute as a group, but `(cmd1; cmd2)` executes them in a
subshell.

###
What does this print:

    ! false && echo $?
===
    0

###
Does this print `hello`?

    name=hello
    cat <<END
    $name
    END
===
Yes.

###
How do you stop variables from being interpolated in heredocs, like here:

    cat <<END
    $name
    END
===
    cat <<'END'
    $name
    END

###
What is the input of `cat` called here:

    cat<<<word
===
A herestring.

###
How do you send output from file descriptor 3 to file descriptor 7 for a command
called `cmd`?
===
    cmd 3>&7

###
How do you grab input for a command called `cmd` from file descriptor 4?
===
    cmd <&4

###
What does this do?

    cmd 2>&1 | tee f1
===
Executes `cmd`, pipes its stderr into stdout, and that's sent to the screen and
file `f1`.

###
What does this do?

    cmd <(cmd1; cmd2)
===
Opens opens up a named pipe or a file descriptor into which `cmd1; cmd2` is
executed and `<(...)` (the first argument in this case) gets replaced with the
path (e.g. `cmd /dev/fd/63`).

###
What gets printed?

    a=2+3; declare -i b; b=$a; echo $b
===
`5`, because `b` is declared as an integer, so the right-hand side gets
evaluated when `b` is assigned to.

###
How do you append elements `ccc` and `ddd` to `array` here:

    array=(aaa bbb)
===
    array+=(ccc ddd)

###
What does this do?

    echo ${name:-John Smith}
===
Prints the value of `$name` if it is set, otherwise prints `John Smith`.

###
What does this do?

    echo ${name:=John Smith}
===
Prints the value of `$name` if it is set, otherwise prints `John Smith` and sets
`$name` to `John Smith`.

###
What does this do?

    echo ${name:?}
===
Prints the value of `$name` if it is set, otherwise it exits and informs that
`$name` isn't set.

###
How do you get the PID of the previous command?
===
`$!`

###
Given `a=3 b=5`, how do you `echo` their sum?
===
    echo $((a + b))

###
What does `! cmd | cmd2` do?
===
Executes `cmd | cmd2` and negates the exit code of the whole.

###
What is the null command?
===
`:`

###
What's the difference between test expression (`[ exp ]`) and the extended test
expression (`[[ exp ]]`)?
===
For the extended version, word splitting and filename expansion are disabled,
additional operators are available: `&&`, `||`, `<`, `>`, and you can use `( )`
for grouping without the need for escaping.

###
If you have `alias top=htop` in your `.bashrc`, what would be the easiest way of
opening `top` if you decided you needed it and not `htop`?
===
`command top`

###
What is `eval` used for?
===
Executing code that might be in a variable like:

    out='> filename'
    eval cat /proc/cpuinfo $out

which will output `/proc/cpuinfo` into `filename`.

###
What does `exec` do?
===
Execute commands in place of the current process? It can also be used for
dealing with redirections.

###
How would you write an arithmetic for loop that just prints 1-10?
===
    for ((i=1; i <= 10; i += 1)); do
        echo $i
    done
###
You have `i` declared as `i=5`. How do you left shift `i` by 3?
===
    (( i = i << 3 ))

###
How do you print all the defined variables?
===
`set`

###
What gets printed in this case: `false | true; echo $?`?
===
`0`, because the last command didn't fail.

###
Running `false | true; echo $?` prints `0` because the last command didn't fail.
How do you make the whole command (`false | true`) fail if one of them fails?
===
`set -o pipefail`

###
How do you assign `first` and `second` to `$1` and `$2` respectively?
===
`set -- first second`

###
How do you test that string `$name` has a nonzero length?
===
`[[ -n $name ]]`

###
In interactive Bash, how do you make it print `No.` if you try to press `Ctrl+C`
(interrupt signal)?
===
`trap 'echo No.' INT`

###
For a given command (say `cmd`), how would you find out if it is a function, an
alias, an external command or other?
===
`type cmd`

###
How do you wait for the most recent background process to finish?
===
`wait $!`
